/*
  Sketch for programming EPROM in Intel D8748H microcontroller using an Arduino Uno

  Note the D8748H uses different programming voltages than the 8748.

  Inspired by a solution by SaabFAN on EEVblog forum for the 8742 and Ardunio Nano:
  https://www.eevblog.com/forum/microcontrollers/simple-programmer-for-vintage-intel-mcs-48-microcontroller/

  Reference: Intel D8748H datasheet http://www.alldatasheet.com/datasheet-pdf/pdf/80208/INTEL/D8748H.html

  Programming the D8748H version requires:
    VCC = 5 +/- 0.25    total supply current @ VCC = 100 mA max
    VDD_H = 21 +/- 1.0 @ 20 mA max
    VDD_L = VCC @ 15 mA max
    PROG_H = 18 +/- 0.5 @ 1 mA max
    PROG_L = float or 4.0 to VCC @ 1 mA max
    EA_H = 18 +/- 0.5 @ 1 mA max
    EA_L = VCC
    also, P10 & P11 must be tied to ground.

  In addition to these signals, the 8748 needs a crystal on pins 2&3, 5V on pin 40 and 0V on pin 20.
  The datasheet says there must be a floating state on PROG.

  Each byte is programmed then read back immediately for verification.  If there is not a match,
  programming stops with an error message.  To test the hardware is working, the "break" statement
  in Step 12 can be commented out and the Arduino will go through the full programming cycle
  without stopping.

  This code is in the public domain.  Use at your own risk, and have fun!
*/

// Put your EPROM program in this array hexProg[].  Use 8bit HEX-Values separated by a ",".
// Set progSize to number of bytes in program.
// The example program data here is for the Inguard processor ROM of the Hewlett Packard 3456A voltmeter.
const int progSize = 1024;
const byte hexProg[progSize] PROGMEM  = {
  0x00, 0x04, 0x05, 0x44, 0x4a, 0x99, 0xf0, 0xb8, 0x1d, 0xb0, 0x00, 0x74, 0x00, 0x89, 0xf7, 0x23,
  0x82, 0x35, 0x62, 0x55, 0x0e, 0xb8, 0x3f, 0x27, 0xa0, 0xe8, 0x18, 0xb8, 0x34, 0xb0, 0x09, 0x0a,
  0xf2, 0x29, 0xd5, 0xbc, 0x0e, 0xc5, 0x05, 0x04, 0x27, 0x04, 0x8c, 0x99, 0xf0, 0x00, 0x89, 0x11,
  0x00, 0x99, 0xe0, 0x89, 0x04, 0x99, 0xf8, 0xb8, 0x14, 0xe8, 0x39, 0x83, 0xd5, 0xfb, 0x32, 0x5e,
  0x99, 0xf0, 0xbd, 0x01, 0x12, 0x6e, 0x34, 0xdc, 0x23, 0xf1, 0x15, 0x90, 0x89, 0x07, 0xc5, 0xb8,
  0x3c, 0xfa, 0xa0, 0x18, 0xfb, 0xa0, 0x18, 0xfc, 0xa0, 0x18, 0xfd, 0xa0, 0x04, 0x86, 0x14, 0x2b,
  0xbd, 0x00, 0x34, 0xdc, 0x34, 0x00, 0x89, 0xf0, 0xd5, 0xbd, 0x01, 0xc5, 0x04, 0x7e, 0xc5, 0xb8,
  0x3c, 0xf0, 0xaa, 0x18, 0xf0, 0xab, 0x18, 0xf0, 0xac, 0x18, 0xf0, 0xad, 0x34, 0x00, 0x23, 0xf1,
  0x15, 0x90, 0x74, 0x00, 0x89, 0x97, 0xb8, 0x3a, 0xf0, 0x62, 0x55, 0x83, 0x27, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x8a, 0xd0, 0x90, 0x37, 0x90, 0xd5, 0x23, 0x87, 0xab, 0x54, 0x00, 0x92, 0xab, 0x14,
  0x3c, 0x54, 0xe1, 0x9a, 0xbf, 0xb8, 0xff, 0xe8, 0xa7, 0x04, 0x8c, 0x97, 0x27, 0xa8, 0xa9, 0xf8,
  0xa3, 0x79, 0xa9, 0x34, 0xeb, 0xe8, 0xaf, 0x90, 0x96, 0x8c, 0x08, 0x04, 0x8c, 0x14, 0x3c, 0x9a,
  0xbf, 0xd5, 0xbc, 0x00, 0x05, 0x04, 0x27, 0xfd, 0x03, 0x66, 0x37, 0xad, 0xfc, 0x03, 0x66, 0x37,
  0xac, 0xfb, 0x03, 0x66, 0x37, 0xab, 0xfa, 0x03, 0x66, 0x37, 0x03, 0x01, 0x57, 0xaa, 0x27, 0x7b,
  0x57, 0xab, 0x27, 0x7c, 0x57, 0xac, 0x27, 0x7d, 0x57, 0xad, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb8, 0x39, 0xf0, 0xae, 0xc6, 0x61, 0x89, 0x18, 0x92, 0x4d, 0x36, 0x53, 0x89, 0x03, 0xa5, 0x00,
  0x00, 0x00, 0xb8, 0x2a, 0x92, 0x59, 0xb0, 0x04, 0x00, 0x00, 0x85, 0x00, 0xb6, 0x6e, 0x36, 0x3d,
  0x99, 0xfa, 0x89, 0x03, 0x00, 0x00, 0x34, 0xbd, 0x95, 0xee, 0x78, 0xb8, 0x39, 0xf0, 0x00, 0xf2,
  0xaa, 0xbf, 0x08, 0xef, 0x33, 0x09, 0xf2, 0x3a, 0x24, 0x7f, 0x99, 0xf2, 0x83, 0x99, 0xfa, 0x89,
  0x06, 0x34, 0xc9, 0x24, 0x28, 0x99, 0xf8, 0x89, 0x06, 0x34, 0xc9, 0x24, 0x28, 0xf2, 0xa6, 0xb9,
  0x00, 0x24, 0x0a, 0x89, 0x06, 0xa5, 0xb5, 0x24, 0x12, 0xb0, 0x08, 0xbf, 0x09, 0xef, 0x5d, 0x24,
  0x1a, 0x89, 0x18, 0xb8, 0x2a, 0xb0, 0x00, 0xa5, 0xb5, 0xbf, 0x18, 0x00, 0x24, 0x33, 0x36, 0x45,
  0x99, 0xf8, 0x89, 0x03, 0x34, 0xbd, 0x24, 0x28, 0xbf, 0x09, 0xef, 0x7a, 0x09, 0xf2, 0x1c, 0x15,
  0x99, 0xf0, 0x89, 0x20, 0xd5, 0x27, 0xac, 0x17, 0xad, 0xc5, 0x23, 0xf1, 0x90, 0x74, 0x00, 0x89,
  0x07, 0xb8, 0x3a, 0xf0, 0x62, 0x55, 0xbd, 0x15, 0xbc, 0x55, 0xb8, 0x08, 0xb0, 0x27, 0x18, 0x27,
  0xa0, 0x23, 0x09, 0xd7, 0x05, 0x83, 0xb9, 0x05, 0x24, 0x0a, 0xe9, 0xb0, 0xbf, 0x06, 0x24, 0x33,
  0xf9, 0x03, 0xff, 0xc6, 0xb9, 0xbe, 0xff, 0x24, 0xd5, 0xbe, 0xe5, 0x24, 0xd5, 0xb8, 0x99, 0x00,
  0xf8, 0x6c, 0x57, 0xac, 0xf8, 0x7d, 0x57, 0xad, 0x83, 0x00, 0x00, 0x23, 0x01, 0x6c, 0x57, 0xac,
  0x27, 0x7d, 0x57, 0xad, 0x83, 0xb8, 0x01, 0xe8, 0xd7, 0x00, 0x24, 0x1c, 0xc5, 0x27, 0xaa, 0xab,
  0xac, 0xad, 0x34, 0x00, 0x89, 0xf0, 0x74, 0x00, 0x14, 0xc7, 0x83, 0xf8, 0xa3, 0x79, 0xa9, 0x44,
  0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xfb, 0xb2, 0x46, 0x9a, 0xdf, 0x32, 0x40, 0x12, 0x3c, 0x89, 0xf0, 0x99, 0xdf, 0xb8, 0x39, 0x72,
  0x2c, 0x52, 0x25, 0xb0, 0x00, 0x18, 0xb0, 0xfb, 0x0a, 0x92, 0x20, 0xfb, 0x53, 0xef, 0xab, 0x83,
  0xfb, 0x43, 0x10, 0x44, 0x1e, 0xb0, 0x0c, 0x18, 0xb0, 0xf1, 0x44, 0x18, 0x52, 0x35, 0xb0, 0x7c,
  0x18, 0xb0, 0xe7, 0x44, 0x18, 0xb0, 0xff, 0x18, 0xb0, 0xe7, 0x44, 0x18, 0xbd, 0x01, 0x44, 0x0d,
  0x89, 0xf0, 0x99, 0xbf, 0x44, 0x0d, 0x8a, 0xb0, 0x44, 0x05, 0xd5, 0xfc, 0x12, 0xc2, 0x00, 0x00,
  0x00, 0x00, 0x08, 0xaa, 0xc6, 0xb9, 0xf2, 0x80, 0xd2, 0x5e, 0xba, 0xf9, 0x44, 0x8a, 0xb2, 0x65,
  0x92, 0x75, 0x3c, 0x44, 0x8c, 0x92, 0x6e, 0x3e, 0x3e, 0x8a, 0x40, 0x3e, 0x44, 0x8c, 0x3f, 0xfc,
  0x53, 0xf7, 0xac, 0x44, 0x8c, 0x9a, 0xbf, 0x3d, 0x3d, 0x3d, 0xfc, 0x53, 0xfd, 0xac, 0x44, 0x8c,
  0xd2, 0x97, 0xab, 0x54, 0x00, 0xaa, 0xfc, 0x53, 0xfb, 0xac, 0xfa, 0x90, 0xb8, 0x08, 0xb0, 0x27,
  0x18, 0x27, 0xa0, 0x23, 0x19, 0xd7, 0x93, 0xfc, 0xc6, 0x9c, 0x44, 0x8c, 0xb8, 0x08, 0xb0, 0xdd,
  0x18, 0xb0, 0x02, 0x23, 0x09, 0xd7, 0x44, 0x96, 0x65, 0xb8, 0x08, 0xb0, 0xbd, 0x18, 0xb0, 0x00,
  0x23, 0x19, 0xd7, 0xbc, 0x01, 0x8a, 0x40, 0x44, 0x96, 0xfc, 0xc6, 0xbe, 0x44, 0x8c, 0x16, 0xa8,
  0x44, 0xbe, 0x27, 0xac, 0x17, 0xad, 0x65, 0x99, 0xf0, 0x89, 0x20, 0x08, 0xaa, 0xc5, 0x74, 0x00,
  0x89, 0x17, 0xb8, 0x3a, 0xf0, 0x62, 0x55, 0xd5, 0x54, 0x00, 0xfa, 0x44, 0x54, 0x54, 0xe1, 0x04,
  0x27, 0xfd, 0x90, 0xb8, 0x0c, 0xe8, 0xe5, 0xfc, 0x90, 0xb8, 0x0c, 0xe8, 0xeb, 0xfb, 0x90, 0xb8,
  0x0c, 0xe8, 0xf1, 0xfa, 0x90, 0x83, 0xf8, 0xa3, 0x79, 0xa9, 0xf8, 0xe3, 0x79, 0xa9, 0x83, 0x00,
  0x99, 0xf0, 0x36, 0xf1, 0x89, 0x03, 0x34, 0xbd, 0xb8, 0x0b, 0xe8, 0x0a, 0xd5, 0xfd, 0xc5, 0x12,
  0xe6, 0x99, 0xdf, 0x00, 0x00, 0x99, 0xe0, 0x74, 0xd6, 0x89, 0x06, 0x99, 0xe0, 0x36, 0xca, 0x85,
  0x00, 0xb9, 0x02, 0xe9, 0x23, 0x42, 0xaf, 0x74, 0xd6, 0x89, 0x03, 0x99, 0xe0, 0xb6, 0xd0, 0xb9,
  0x1a, 0xe9, 0x31, 0xb9, 0x2a, 0x74, 0xd4, 0x89, 0x05, 0x99, 0xe0, 0xfe, 0x37, 0x17, 0x6f, 0xae,
  0xf1, 0x76, 0xba, 0x37, 0x17, 0x6e, 0xf2, 0xbc, 0x00, 0x00, 0x74, 0xda, 0xb8, 0x00, 0xb9, 0x31,
  0xb1, 0x00, 0xbe, 0x05, 0xee, 0x54, 0x31, 0x47, 0xae, 0xf1, 0x47, 0x6b, 0x57, 0xab, 0xfe, 0x7c,
  0x74, 0xb3, 0x00, 0xb8, 0x05, 0xe8, 0x65, 0x74, 0xd4, 0x89, 0x01, 0x99, 0xe0, 0xfe, 0x74, 0xda,
  0xb8, 0x00, 0x6b, 0x74, 0xaf, 0x00, 0xb8, 0x19, 0xe8, 0x78, 0x74, 0xd4, 0x89, 0x04, 0x99, 0xe0,
  0xfe, 0x74, 0xda, 0x74, 0xea, 0xb9, 0x34, 0xb1, 0x09, 0xb8, 0x99, 0x31, 0x47, 0xae, 0xf1, 0x47,
  0x6a, 0x57, 0xaa, 0xfe, 0x7b, 0x74, 0xaf, 0xb9, 0x34, 0xb1, 0x09, 0xb9, 0x31, 0xb1, 0x00, 0xb8,
  0x0d, 0xe8, 0xa1, 0x89, 0x10, 0x42, 0x74, 0xda, 0xb8, 0x00, 0x6a, 0x57, 0xaa, 0xfb, 0x78, 0x57,
  0xab, 0xfc, 0x78, 0x57, 0xac, 0xfd, 0x78, 0x57, 0xad, 0x83, 0x64, 0x45, 0x37, 0x17, 0x74, 0xda,
  0x74, 0xea, 0xb8, 0x99, 0xb9, 0x34, 0xb1, 0x09, 0x64, 0x56, 0x85, 0x95, 0xb9, 0x1a, 0x64, 0x23,
  0x00, 0x00, 0x64, 0x33, 0x42, 0xae, 0x45, 0x27, 0x62, 0x83, 0x03, 0x00, 0x92, 0xe1, 0x00, 0x64,
  0xe4, 0x57, 0x03, 0x06, 0x57, 0x83, 0x99, 0xbf, 0x64, 0x15, 0x03, 0x66, 0x37, 0x03, 0x01, 0x57,
  0x83, 0x89, 0x06, 0x34, 0xc9, 0xb8, 0x0a, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13
};

// Pin assignments from Uno to the 8748
int DB0 = 2;      //DB0-DB7 are 8748 pins 12-19
int DB1 = 3;
int DB2 = 4;
int DB3 = 5;
int DB4 = 6;
int DB5 = 7;
int DB6 = 8;
int DB7 = 9;
int P20 = 10;     //P20, P21 are 8748 pins 21, 22
int P21 = 11;
int TEST0 = 12;   // 8748 pin 1
int RESET = 13;   // 8748 pin 4
int EA_H = A0;    // transistor switch for EA high  (8748 pin 7)
int VDD_H = A1;   // transistor switch for VDD high (8748 pin 26)
int PROG_H = A2;  // transistor switch for PROG high (8748 pin 25)

int incomingByte;
boolean programmedFlag = false;
boolean errorFlag = false;

//--------------------------------------------------------------------------------------
void setup() {
  Serial.begin(9600);     // Actions will be echoed to the monitor.  Make sure it is open.

  // Setup the Control-Pins
  pinMode(P20, OUTPUT);
  pinMode(P21, OUTPUT);
  pinMode(TEST0, OUTPUT);
  pinMode(RESET, OUTPUT);
  pinMode(EA_H, OUTPUT);
  pinMode(VDD_H, OUTPUT);
  pinMode(PROG_H, OUTPUT);
  //DB0-7 are bidirectional, so set their mode later.

  // Initial state from data sheet
  digitalWrite(TEST0, HIGH);    // 5V
  digitalWrite(RESET, LOW);     // 0V
  digitalWrite(EA_H, LOW);      // EA = 5V
  digitalWrite(VDD_H, LOW);     // VDD = 5V
  digitalWrite(PROG_H, LOW);    // PROG floating

  Serial.println("D8748H Programmer READY");
  Serial.println("Command: press p to program 8748 EPROM");
  Serial.println();
}
//--------------------------------------------------------------------------------------
void loop() {
  if (Serial.available() > 0) {

    incomingByte = Serial.read();

    if (incomingByte == 'p') {
      if (!programmedFlag) {  // prevent accidental attempt to reprogram chip
        Program_8748();
        programmedFlag = true;
      }
    }
  }

}

//--------------------------------------------------------------------------------------
void Program_8748() {
  // Steps are from datasheet programming instructions.  Steps 1 and 2 already done in setup().

  // Step 3: TEST0 = 0V (select program mode).
  digitalWrite(TEST0, LOW);
  delay(1);          // 8748 needs at least 4 clock cycles (~20 uS) to process each change

  // Step 4: EA = 18V (activate program mode),
  digitalWrite(EA_H, HIGH);
  delay(1);

  for (int address = 0; address < progSize; address++) {
    // Step 5 (repeats from here for all program bytes): Address applied to BUS and P20-1.
    pinMode(DB0, OUTPUT);
    pinMode(DB1, OUTPUT);
    pinMode(DB2, OUTPUT);
    pinMode(DB3, OUTPUT);
    pinMode(DB4, OUTPUT);
    pinMode(DB5, OUTPUT);
    pinMode(DB6, OUTPUT);
    pinMode(DB7, OUTPUT);

    digitalWrite(DB0, bitRead(address, 0));  // output the address
    digitalWrite(DB1, bitRead(address, 1));
    digitalWrite(DB2, bitRead(address, 2));
    digitalWrite(DB3, bitRead(address, 3));
    digitalWrite(DB4, bitRead(address, 4));
    digitalWrite(DB5, bitRead(address, 5));
    digitalWrite(DB6, bitRead(address, 6));
    digitalWrite(DB7, bitRead(address, 7));
    digitalWrite(P20, bitRead(address, 8));
    digitalWrite(P21, bitRead(address, 9));
    delay(1);

    // Step 6: RESET = 5V (latch address).
    digitalWrite(RESET, HIGH);
    delay(1);

    // Step 7: Data applied to BUS.
    digitalWrite(DB0, bitRead(hexProg[address], 0));
    digitalWrite(DB1, bitRead(hexProg[address], 1));
    digitalWrite(DB2, bitRead(hexProg[address], 2));
    digitalWrite(DB3, bitRead(hexProg[address], 3));
    digitalWrite(DB4, bitRead(hexProg[address], 4));
    digitalWrite(DB5, bitRead(hexProg[address], 5));
    digitalWrite(DB6, bitRead(hexProg[address], 6));
    digitalWrite(DB7, bitRead(hexProg[address], 7));
    delay(1);

    // Step 8: VDD = 21V (programming power).
    digitalWrite(VDD_H, HIGH);
    // datasheet says no delay needed here.

    // Step 9: PROG = float followed by one 50 to 60 ms pulse to 18V.
    digitalWrite(PROG_H, HIGH);
    delay(55);
    digitalWrite(PROG_H, LOW);
    // datasheet says no delay needed here.

    // Step 10: VDD = 5V.
    digitalWrite(VDD_H, LOW);
    delay(1);

    // Step 11: TEST0 = 5V (verify mode).
    digitalWrite(TEST0, HIGH);
    delay(1);

    // Step 12: Read and verify data on BUS.
    byte verifyByte = readByte(address);
    if (verifyByte != hexProg[address]) {
      errorFlag = true;
      Serial.print("ERROR ---> ");
      Serial.print("address = ");
      Serial.print(address, HEX);
      Serial.print(" program byte = ");
      Serial.print(hexProg[address], HEX);
      Serial.print(" verified byte = ");
      Serial.println(verifyByte, HEX);
      break;    // jump out of loop
    }


    // Step 13: TEST0 = 0V.
    digitalWrite(TEST0, LOW);
    delay(1);

    // Step 14:  RESET = OV and repeat from step 5.
    digitalWrite(RESET, LOW);
    delay(1);

  }   // end loop

  // Step 15: Programmer should be at conditions of step 1 when 8748 is removed from socket.
  digitalWrite(TEST0, HIGH);    // 5V
  digitalWrite(RESET, LOW);     // 0V
  digitalWrite(EA_H, LOW);      // EA = 5V
  digitalWrite(VDD_H, LOW);     // VDD = 5V
  digitalWrite(PROG_H, LOW);

  if (errorFlag) {
    Serial.println("Exited with ERROR!");
  } else {
    Serial.println("EPROM programmed successfully.");
  }
}

//--------------------------------------------------------------------------------------
byte readByte(int address) {
  // Returns the EPROM byte at location "address".
  byte result;

  // make sure EA is high and PROG is floating (they should be anyway)
  digitalWrite(EA_H, HIGH);
  digitalWrite(PROG_H, LOW);
  delay(1);

  // put the address on the bus
  digitalWrite(DB0, bitRead(address, 0));
  digitalWrite(DB1, bitRead(address, 1));
  digitalWrite(DB2, bitRead(address, 2));
  digitalWrite(DB3, bitRead(address, 3));
  digitalWrite(DB4, bitRead(address, 4));
  digitalWrite(DB5, bitRead(address, 5));
  digitalWrite(DB6, bitRead(address, 6));
  digitalWrite(DB7, bitRead(address, 7));
  digitalWrite(P20, bitRead(address, 8));
  digitalWrite(P21, bitRead(address, 9));
  delay(1);

  // latch address in 8748
  digitalWrite(RESET, HIGH);
  delay(1);

  // switch pins to input mode
  pinMode(DB0, INPUT);
  pinMode(DB1, INPUT);
  pinMode(DB2, INPUT);
  pinMode(DB3, INPUT);
  pinMode(DB4, INPUT);
  pinMode(DB5, INPUT);
  pinMode(DB6, INPUT);
  pinMode(DB7, INPUT);

  // have 8748 put data on bus
  digitalWrite(TEST0, HIGH);
  delay(1);

  // read the data
  result =
    digitalRead(DB0) * 1 +
    digitalRead(DB1) * 2 +
    digitalRead(DB2) * 4 +
    digitalRead(DB3) * 8 +
    digitalRead(DB4) * 16 +
    digitalRead(DB5) * 32 +
    digitalRead(DB6) * 64 +
    digitalRead(DB7) * 128;

  // turn off read mode
  digitalWrite(RESET, LOW);
  digitalWrite(TEST0, LOW);
  delay(1);

  // put pins back into output mode
  pinMode(DB0, OUTPUT);
  pinMode(DB1, OUTPUT);
  pinMode(DB2, OUTPUT);
  pinMode(DB3, OUTPUT);
  pinMode(DB4, OUTPUT);
  pinMode(DB5, OUTPUT);
  pinMode(DB6, OUTPUT);
  pinMode(DB7, OUTPUT);

  return result;
}





